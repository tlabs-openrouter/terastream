From 74819c9d21427422f42d76141f23ffc1f3cb1a13 Mon Sep 17 00:00:00 2001
From: Leonardo Jelenkovic <leonardo.jelenkovic@gmail.com>
Date: Mon, 16 Jun 2014 14:58:24 +0200
Subject: [PATCH 15/17] code-style and simplifications

---
 networking/udhcp/dhcp4o6.c | 47 ++++++++++++++++++++++------------------------
 networking/udhcp/dhcpc.c   | 22 +++++++---------------
 2 files changed, 29 insertions(+), 40 deletions(-)

diff --git a/networking/udhcp/dhcp4o6.c b/networking/udhcp/dhcp4o6.c
index 4a8f9fa..7d69470 100644
--- a/networking/udhcp/dhcp4o6.c
+++ b/networking/udhcp/dhcp4o6.c
@@ -52,16 +52,15 @@ static void *d6_find_option(uint8_t *option, uint8_t *option_end, unsigned code)
 		len_m4 -= option[3] + 4;
 	}
 #else
-	/* D6_OPT_DHCPV4_MSG option is larger than 255 since whole DHCPv4
-	 * packet is in it, so the above assumptions are not valid */
-	unsigned opt_len, opt_code;
+	/* D6_OPT_DHCPV4_MSG option is (possibly) larger than 255 since whole
+	 * DHCPv4 packet is in it, so the above assumptions are not valid */
+	unsigned opt_len;
 	while (option < option_end) {
 		opt_len =  (option[2]<<8) + option[3];
-		opt_code = (option[0]<<8) + option[1];
 		if (option + 4 + opt_len > option_end)
 			return NULL; /* option not found */
 		/* Does its code match? */
-		if (opt_code == code)
+		if (code == (option[0]<<8) + option[1])
 			return option; /* yes! */
 		option += opt_len;
 	}
@@ -247,7 +246,7 @@ static int d6_raw_socket(int ifindex)
 	sock.sll_ifindex = ifindex;
 	xbind(fd, (struct sockaddr *) &sock, sizeof(sock));
 
-#if 1 /* not working! */
+#if 1
 	if (CLIENT_PORT6 == 546) {
 		/* Use only if standard port is in use */
 		/* Ignoring error (kernel may lack support for this) */
@@ -272,8 +271,8 @@ int dhcp4o6_init (int port, char *cip6, char *sip6)
 {
 	struct in6_addr ip6;
 
-	memset ( &dhcp4o6_data.dst_ip, 0, 16 );
-	memset ( &dhcp4o6_data.src_ip, 0, 16 );
+	memset(&dhcp4o6_data.dst_ip, 0, 16);
+	memset(&dhcp4o6_data.src_ip, 0, 16);
 
 	if (port) {
 		dhcp4o6_data.src_port = CLIENT_PORT;
@@ -284,10 +283,9 @@ int dhcp4o6_init (int port, char *cip6, char *sip6)
 		dhcp4o6_data.dst_port = 547;
 	}
 
-	if (!cip6 || inet_pton(AF_INET6, cip6, &ip6) != 1) {
-		bb_error_msg("Valid local (client) IPv6 address must be provided!");
-		exit(1);
-	}
+	if (!cip6 || inet_pton(AF_INET6, cip6, &ip6) != 1)
+		bb_error_msg_and_die("Valid local (client) IPv6 address must be provided!");
+
 	dhcp4o6_data.src_ip = ip6;
 
 	if (sip6 && inet_pton(AF_INET6, sip6, &ip6) > 0) {
@@ -301,9 +299,8 @@ int dhcp4o6_init (int port, char *cip6, char *sip6)
 		dhcp4o6_data.dst_ip.s6_addr[15] = 0x02;
 	}
 	else {
-		bb_error_msg("Valid DHCP4oDHCP6 server IPv6 address must be "
-		"provided, or multicast specified by 'mcast' instead!");
-		exit(1);
+		bb_error_msg_and_die("Valid DHCP4oDHCP6 server IPv6 address must"
+		"be provided, or multicast specified by 'mcast' instead!");
 	}
 
 	//FIXME choose between SOCKET_RAW and SOCKET_KERNEL with additional flag!
@@ -317,9 +314,9 @@ int dhcp4o6_open_socket(int mode UNUSED_PARAM)
 {
 	int sockfd6 = -1;
 
-	if ( dhcp4o6_data.socket_mode == SOCKET_RAW )
+	if (dhcp4o6_data.socket_mode == SOCKET_RAW)
 		sockfd6 = d6_raw_socket(client_config.ifindex);
-	else if ( dhcp4o6_data.socket_mode == SOCKET_KERNEL )
+	else if (dhcp4o6_data.socket_mode == SOCKET_KERNEL)
 		sockfd6 = d6_listen_socket(dhcp4o6_data.src_port,
 						client_config.interface);
 	/* else LISTEN_NONE: sockfd stays closed */
@@ -335,26 +332,26 @@ static int dhcp4o6_get_dhcpv4_from_dhcpv6 (
 
 	/* check DHCPv6 packet in d6_pkt */
 
-	if ( d6_pkt->d6_msg_type != D6_MSG_DHCPV4_RESPONSE ) {
+	if (d6_pkt->d6_msg_type != D6_MSG_DHCPV4_RESPONSE) {
 		log1("Packet is not of D6_MSG_DHCPV4_RESPONSE type");
 		return -1;
 	}
 
 	d6opt = d6_find_option ( d6_pkt->d6_options, (void *) (d6_pkt+1), D6_OPT_DHCPV4_MSG );
-	if ( ! d6opt ) {
+	if (!d6opt) {
 		log1("D6_OPT_DHCPV4_MSG option not found");
 		return -1;
 	}
 	/* D6_OPT_DHCPV4_MSG must be first option? Where is that defined? FIXME */
 
 	opt_len = (d6opt[2]<<8) + d6opt[3];
-	if ( opt_len < DHCP_SIZE - DHCP_OPTIONS_BUFSIZE ) {
+	if (opt_len < DHCP_SIZE - DHCP_OPTIONS_BUFSIZE) {
 		log1("D6_OPT_DHCPV4_MSG option too small");
 		return -1;
 	}
 
 	/* extract dhcpv4 packet from dhcpv6 option */
-	memcpy ( d4_pkt, d6opt + 4, opt_len );
+	memcpy(d4_pkt, d6opt + 4, opt_len);
 
 	return opt_len;
 }
@@ -374,7 +371,7 @@ int dhcp4o6_recv_packet (struct dhcp_packet *packet4, int fd)
 	if ( ret < 0 )
 		return -1;
 
-	ret = dhcp4o6_get_dhcpv4_from_dhcpv6 (&packet6, packet4);
+	ret = dhcp4o6_get_dhcpv4_from_dhcpv6(&packet6, packet4);
 	if ( ret < 0 )
 		return 0;
 	else
@@ -390,7 +387,7 @@ int dhcp4o6_send_packet (struct dhcp_packet *packet4, int bcast )
 
 	/* asemble DHCPv6 packet */
 
-	if ( bcast )
+	if (bcast)
 		flags = 0;
 	else
 		flags = htonl(0x00800000); /* unicast flag */
@@ -399,14 +396,14 @@ int dhcp4o6_send_packet (struct dhcp_packet *packet4, int bcast )
 			udhcp_end_option (packet4->options) + 1;
 
 	/* create DHCPv6 packet of type D6_MSG_DHCPV4_QUERY */
-	opt = (void *) init_d6_packet ( &packet6, D6_MSG_DHCPV4_QUERY, flags );
+	opt = (void *) init_d6_packet(&packet6, D6_MSG_DHCPV4_QUERY, flags);
 
 	/* content of DHCPv6 packet is option D6_OPT_DHCPV4_MSG with DHCPv4 packet */
 	opt->code_hi = 0;
 	opt->code = D6_OPT_DHCPV4_MSG;
 	opt->len_hi = d4size >> 8;
 	opt->len = d4size & 0x00ff;
-	memcpy ( opt->data, packet4, d4size );
+	memcpy(opt->data, packet4, d4size);
 
 	d6size = 4 + 4 + d4size; /* d6 header + option header + d4 packet */
 
diff --git a/networking/udhcp/dhcpc.c b/networking/udhcp/dhcpc.c
index b108c93..33f9073 100644
--- a/networking/udhcp/dhcpc.c
+++ b/networking/udhcp/dhcpc.c
@@ -672,33 +672,27 @@ static void add_client_options(struct dhcp_packet *packet)
 static int raw_bcast_from_client_config_ifindex(struct dhcp_packet *packet)
 {
 #if ENABLE_FEATURE_DHCP4o6C
-	if ( !client_config.mode4o6 )
+	if ( client_config.mode4o6 )
+		return dhcp4o6_send_packet (packet, 1);
 #endif
 	return udhcp_send_raw_packet(packet,
 		/*src*/ INADDR_ANY, CLIENT_PORT,
 		/*dst*/ INADDR_BROADCAST, SERVER_PORT, MAC_BCAST_ADDR,
 		client_config.ifindex);
-#if ENABLE_FEATURE_DHCP4o6C
-	else
-		return dhcp4o6_send_packet (packet, 1);
-#endif
 }
 
 static int bcast_or_ucast(struct dhcp_packet *packet, uint32_t ciaddr, uint32_t server)
 {
 	if (server)
 #if ENABLE_FEATURE_DHCP4o6C
-	{
-		if ( !client_config.mode4o6 )
+		if ( client_config.mode4o6 )
+			return dhcp4o6_send_packet(packet, 0);
+		else
 #endif
 		return udhcp_send_kernel_packet(packet,
 			ciaddr, CLIENT_PORT,
 			server, SERVER_PORT);
-#if ENABLE_FEATURE_DHCP4o6C
-		else
-			return dhcp4o6_send_packet(packet, 0);
-	}
-#endif
+
 	return raw_bcast_from_client_config_ifindex(packet);
 }
 
@@ -1278,7 +1272,7 @@ int udhcpc_main(int argc UNUSED_PARAM, char **argv)
 	uint8_t *temp, *message;
 	const char *str_V, *str_h, *str_F, *str_r;
 	IF_FEATURE_UDHCP_PORT(char *str_P;)
-	IF_FEATURE_DHCP4o6C(char *str_6c, *str_6s;)
+	IF_FEATURE_DHCP4o6C(char *str_6c = NULL, *str_6s = NULL;)
 	void *clientid_mac_ptr;
 	llist_t *list_O = NULL;
 	llist_t *list_x = NULL;
@@ -1419,8 +1413,6 @@ int udhcpc_main(int argc UNUSED_PARAM, char **argv)
 #if ENABLE_FEATURE_DHCP4o6C
 	if ( (opt & OPT_6) ) {
 		client_config.mode4o6 = 1;
-		if ( !(opt & OPT_I) )
-			str_6c = NULL;
 #if ENABLE_FEATURE_UDHCP_PORT
 		dhcp4o6_init ((opt & OPT_P), str_6c, str_6s);
 #else
-- 
2.0.1

