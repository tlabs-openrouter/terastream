#!/bin/sh

# global variables:
#
#   interface - the interface name dhclient is operating on
#   INTERFACE - the uci config name provided to dhclient with -eINTERFACE=
#

. /lib/functions.sh
. /lib/netifd/netifd-proto.sh
. /lib/config/uci.sh

ip=/usr/sbin/ip

_remembered_states="_old_ad_ADDRESSES _old_ad_RA_ADDRESSES _old_ad_PREFIXES _old_DHCP4_O_DHCP6_SERVERS _old_DHCP4_O_DHCP6_MODE _old_OPTION_199 \
                    _old_AFTR _old_AFTR_IP _old_NTP_IP _old_NTP_FQDN _old_SNTP_IP _old_RDNSS _old_RA_DNS _old_OPTION_124 _old_OPTION_125 \
                    _old_SIP_DOMAIN"

remember_values() {
	for varname in $_remembered_states; do
		export $varname="$(uci_get_state network $INTERFACE odhcp6c_${varname})"

		local curr_name="${varname#_old_}"

		if [ "$(echo -n $curr_name | head -c 3)" = "ad_" ]; then
			curr_name="${curr_name#ad_}"
			curr_value=$(echo -n "$(eval echo \$$curr_name)")

			local state_value=""


			for addr in $curr_value; do
				[ -n "$state_value" ] && state_value="$state_value "
				state_value="${state_value}${addr%%,*}"
			done

			[ -n "$state_value" ] && uci_set_state network $INTERFACE "odhcp6c_${varname}" "${state_value}"
		else
			curr_value=$(echo -n "$(eval echo \$$curr_name)")

			[ -n "$curr_value" ] && uci_set_state network $INTERFACE "odhcp6c_${varname}" "${curr_value}"
		fi
	done
}

clear_states() {
	for varname in $_remembered_states; do
		uci_revert_state network "$INTERFACE" "odhcp6c_$varname"
	done
}

get_plain_addresses() {
	for varname in $_remembered_states; do
		local dhcp_var_name="${varname#_old_ad_}"
		local dhcp_var_value=$(echo -n "$(eval echo \$$dhcp_var_name)")

		local state_value=""

		for addr in $dhcp_var_value; do
			[ -n "$state_value" ] && state_value="$state_value "
			state_value="${state_value}${addr%%,*}"
		done

		export "ad_${dhcp_var_name}"="${state_value}"
	done
}

log() {
	logger -t dhcp6_terastream $interface: $*
}

ip6addr_from_hexstr() {
	local hex_str="$1"

	[ ${#hex_str} -eq 32 ] || { echo -n ""; return 1; }

	local ip6addr=$(echo -n "$hex_str" | sed -re 's/(.{4})/\1:/g')
	ip6addr=${ip6addr%:}

	echo -n "$ip6addr"

	return 0
}

unhex() {
	echo -n "$1" | sed 's/\([0-9A-F]\{2\}\)/\\\\\\x\1/gI' | xargs printf
}

wait_for_slaac_done() {
	local ifname="$1"
	local res=""

	while [ -z "$res" ]; do
		res=$($ip -6 addr show dev "$ifname" | grep -E "scope global (nodad )?dynamic")
		sleep 2
	done
}

preinit6() {
	interface="$1"
}

handle_sntpservers() {
	local sntp_servers=$1
	local ntp_args="-l"

	[ -z "$sntp_servers" ] && return
	
	for sntp_server in $sntp_servers; do
		ntp_args="$ntp_args -p $sntp_server"
	done

	log "Using NTP servers: $sntp_servers"

	killall -TERM ntpd 2>/dev/null
	sleep 1
	
	/usr/sbin/ntpd $ntp_args 
}

is_up() {
	local iface="$1"
	ifstatus "$iface" | grep -q "\"up\": true,"
}

host_address_from_prefix() {
	local prefix=$1

	[ -z "$prefix" ] && return 1

	prefix="$(echo ${prefix} | ipv6calc --printuncompressed | cut -d ':' -f -7):1"

	ipv6calc --in ipv6addr --out ipv6addr "$prefix"

	return 0
}

# some AFTR setting has changed (already checked in main entry)

handle_aftr() {
	local iface="$1"
	local aftr_fqdn="$2"
	local aftr_ip="$3"
	local ra_addresses="$4"
	local addresses="$5"
	local dhcp4o6_servers="$6"
	local dhcp4o6_mode="$7"
	local b4_address="$8"

	local aftr_local=""

	aftr_local="${aftr_local:-$(ip6addr_from_hexstr "$b4_address")}"
	aftr_local="${aftr_local:-${ra_addresses%%/*}}"
	aftr_local="${aftr_local:-${addresses%%/*}}"

	local aftr_remote="${aftr_ip:-$(decode_hostname $aftr_fqdn)}"

	log "AFTR: name: $aftr_fqdn remote_ip: $aftr_remote local_ip: $aftr_local"
    log "DHCPv4oDHCPv6 servers: $dhcp4o6_servers"

	# store AFTR related settings in UCI states
	uci_set_state network $iface aftr_local "$aftr_local"
	uci_set_state network $iface aftr_remote "$aftr_remote"
	uci_set_state network $iface aftr_dhcp4o6_servers "$dhcp4o6_servers"
	uci_set_state network $iface aftr_dhcp4o6_mode "$dhcp4o6_mode"

	# reload child interfaces
	is_up wan_ds && {
		log "AFTR settings have changed. Restarting dslite tunnel."
		ifup wan_ds
	} || {
		log "AFTR settings received. Enabling dslite tunnel."
		proto_set_available wan_ds 1
	}

}

# SIP domain has changed (already checked in main entry)

handle_sip_domain() {
	local iface="$1"
	local sip_domain="$2"
	
	uci_set_state network $iface sip_domain "$sip_domain"
}

remove_aftr() {
	local iface=$1
	log "Removing AFTR settings for $iface."

	uci_revert_state network $iface aftr_local
	uci_revert_state network $iface aftr_remote
	uci_revert_state network $iface aftr_dhcp4o6_servers
}

handle_ip6_prefixes()
{
	local PREFIXES="$1"

	for prefix_info in $PREFIXES; do
		local iaid="${prefix_info#*,class=*}"
		local prefix_name="$(unhex $iaid)"
		local prefix="${prefix_info%%,*}"

		log "Using prefix $prefix (IAID=\"$prefix_name\")"
		proto_add_ipv6_prefix "$prefix_info"

		# block INPUT traffic to lan prefix
		if [ "${prefix_name}" = "_ANY" ]; then
			ip6tables -w -F deny_lan
			ip6tables -w -A deny_lan -p all -d "$prefix" -j REJECT
		fi
        
		# save VoIP prefix address
		if [ "${prefix_name}" = "VOIP" ]; then
			local voip_address=$(host_address_from_prefix "${prefix%/*}")
			[ -n "$voip_address" ] && {
			log "Saving \"$voip_address\" as VoIP from address."
			uci_set_state network wan sip_bindaddr "$voip_address"
		} || log "Error calculating VoIP from address!"
	fi
done
}

handle_local_addresses() {
	local RA_ADDRESSES="$1"
	local ADDRESSES="$2"

	# Merge addresses

        for entry in $RA_ADDRESSES; do
                local duplicate=0
                local addr="${entry%%/*}"
                for dentry in $ADDRESSES; do
                        local daddr="${dentry%%/*}"
                        [ "$addr" = "$daddr" ] && duplicate=1
                done
                [ "$duplicate" = "0" ] && ADDRESSES="$ADDRESSES $entry"
        done

        for entry in $ADDRESSES; do
                local addr="${entry%%/*}"
                entry="${entry#*/}"
                local mask="${entry%%,*}"
                entry="${entry#*,}"
                local preferred="${entry%%,*}"
                entry="${entry#*,}"
                local valid="${entry%%,*}"

                proto_add_ipv6_address "$addr" "$mask" "$preferred" "$valid" 1
        done
}

handle_routes() {
	local RA_ROUTES="$1"

        for entry in $RA_ROUTES; do
                local addr="${entry%%/*}"
                entry="${entry#*/}"
                local mask="${entry%%,*}"
                entry="${entry#*,}"
                local gw="${entry%%,*}"
                entry="${entry#*,}"
                local valid="${entry%%,*}"
                entry="${entry#*,}"
                local metric="${entry%%,*}"

                proto_add_ipv6_route "$addr" "$mask" "$gw" "$metric" "$valid"
        done
}

handle_nameservers() {
	local RA_DNS="$1"
	local RDNSS="$2"

        # Merge RA-DNS
        for radns in $RA_DNS; do
                local duplicate=0
                for dns in $RDNSS; do
                        [ "$radns" = "$dns" ] && duplicate=1
                done
                [ "$duplicate" = 0 ] && RDNSS="$RDNSS $radns"
        done

        for dns in $RDNSS; do
                proto_add_dns_server "$dns"
        done
}

handle_ia_b4() {
	local b4_hexstr="$1"

	local b4_address=$(ip6addr_from_hexstr "$b4_hexstr")

	[ $? -ne 0 ] && { log "couldn't convert hexstr $b4_hexstr into ip6 address"; return; }

	proto_add_ipv6_address "$b4_address" 128 0
}

handle_mcast_aftr() {
	local iface="$1"
	local opt124="$2"
	local ra_addresses="$3"
	local addresses="$4"
	local b4_address="$5"

	# remove garbage after \0 byte
	local clean_opt_124="$(echo -n $opt124 | sed -re 's/^(.{2}+)00.*/\1/')"
	local remote_aftr_fqdn="$(decode_hostname $(unhex $clean_opt_124))"

	logger -t "$iface" -- "Got new mcast_aftr: ${remote_aftr_fqdn}"

	uci_set_state network "$iface" "mc_aftr_remote" "${remote_aftr_fqdn}"

	local aftr_local=""
	
	aftr_local="${aftr_local:-$(ip6addr_from_hexstr "$b4_address")}"
	aftr_local="${aftr_local:-${ra_addresses%%/*}}"
	aftr_local="${aftr_local:-${addresses%%/*}}"

	uci_set_state network "$iface" "mc_aftr_local" "${aftr_local}"

	logger -t "$iface" -- "Using $local_addr as local tunnel endpoint."
}

handle_mcast_ip() {
	local iface="$1"

	# remove garbage after \0 byte
	local clean_opt_125="$(echo -n $OPTION_125 | sed -re 's/^(.{2}+)00.*/\1/')"
	local mcast_ip="$(unhex $clean_opt_125)"
	local hacked_server_ip="$(echo -n $mcast_ip | cut -d. -f1-3).1"

	logger -t "$iface" "Got new mcast_ip: ${mcast_ip}. Derived remote IP: $hacked_server_ip"

	uci_set_state network "$iface" "mc_aftr_v4_local" "$mcast_ip"
	uci_set_state network "$iface" "mc_aftr_v4_remote" "$hacked_server_ip"
}

trigger_iptv_reload() {
	logger -t "$INTERFACE" "Triggering IPTV reload."

	is_up iptv && {
		ifdown iptv
		sleep 2
		ifup iptv
	}
}

update_ncs_fqdn() {
	local addresses_have_changed="$1"
	
	# export NCS to uci
	old_ncs=$(uci_get_state freenetconfd @freenetconfd[0] ncs)
	[ -n "$NCS" ] && {
		uci_set_state freenetconfd @freenetconfd[0] ncs "$NCS"
		log "set NCS FQDN in uci state freenetconfd.@freenetconfd[0].ncs to '$NCS'"
	}

	# trigger port knocking when either the NCS or our IP address has changed
	knockknock=/usr/bin/ncs_knocknock.sh
	[ \( "$NCS" != "$old_ncs" -o -n "$addresses_have_changed" \) -a -x $knockknock ] && {
		$knockknock
	}
}

check_addresses_changed() {
	[ "$_old_ad_ADDRESSES" != "$ad_ADDRESSES" -o "$_old_ad_RA_ADDRESSES" != "$ad_RA_ADDRESSES" ] && return 1

	return 0
}

check_prefixes_changed() {
	[ "$_old_ad_PREFIXES" != "$ad_PREFIXES" ] && return 1

	return 0
}

check_modeswitchbug_cornercase() {
	old_ad_PREFIXES_cnt=$(echo -n "$_old_ad_PREFIXES" | wc -w)
	ad_PREFIXES_cnt=$(echo -n "$ad_PREFIXES" | wc -w)

	[ $ad_PREFIXES_cnt -ne 0 ] && return 0

	[ $old_ad_PREFIXES_cnt -ne 1 ] && return 0

	return 1	
}

check_ia_b4_changed() {
	[ "$_old_OPTION_199" != "$OPTION_199" ] && return 1

	return 0
}

check_aftr_changed() {
	[ "$_old_AFTR" != "$AFTR" -o "$_old_AFTR_IP" != "$AFTR_IP" ] && return 1

	return 0
}

check_dhcp4o6_changed() {
	[ "$_old_DHCP4_O_DHCP6_MODE" != "$DHCP4_O_DHCP6_MODE" ] && return 1 
	[ "$_old_DHCP4_O_DHCP6_SERVERS" != "$DHCP4_O_DHCP6_SERVERS" ] && return 1 
	return 0
}

check_dns_changed() {
	[ "$_old_RA_DNS" != "$RA_DNS" -o "$_old_RDNSS" != "$RDNSS" ] && return 1

	return 0
}

check_sntp_changed() {
	[ "$_old_NTP_FQDN" != "$NTP_FQDN" -o "$_old_NTP_IP" != "$NTP_IP" -o "$_old_SNTP_IP" != "$SNTP_IP" ] && return 1

	return 0
}

check_mcast_aftr_changed() {
	[ "$_old_OPTION_124" != "$OPTION_124" ] && return 1

	return 0
}

check_mcast_ip_changed() {
	[ "$_old_OPTION_125" != "$OPTION_125" ] && return 1

	return 0
}

check_sip_domain_changed() {
	[ "$_old_SIP_DOMAIN" != "$SIP_DOMAIN" ] && return 1
	
	return 0
}

reason="$2"
interface="$1"

log "reason: $reason interface: $interface"

# use DHCPv4ov6 servers from option 88 (RFC 7341), if available
# else use old style DHCPv4ov6 servers from option 99.

if [ -n "$DHCP4_O_DHCP6_SERVERS_88" ]; then
	DHCP4_O_DHCP6_SERVERS="$DHCP4_O_DHCP6_SERVERS_88"
	DHCP4_O_DHCP6_MODE="rfc7341"
else
	DHCP4_O_DHCP6_SERVERS="$DHCP4_O_DHCP6_SERVERS_99"
	DHCP4_O_DHCP6_MODE="terastream"
fi

remember_values

get_plain_addresses

case "$reason" in
	started)
		clear_states

		preinit6 "$interface"
		
		[ -n "$OPTION_1" ] && uci_set_state network $INTERFACE "dhcpv6_duid" "$OPTION_1"

		;;

	ra-updated)
		proto_init_update "$interface" 1 # lower case $interface is the ifname
		proto_set_keep 1                 # make sure pre-configured addresses / routes stay

		# Set local IPv6 Address
		handle_local_addresses "$RA_ADDRESSES" "$ADDRESSES"

		# Set routes
		handle_routes "$RA_ROUTES"

		proto_send_update "$INTERFACE" # upper case $INTERFACE is the virtual interface
		
		# update NCS FQDN
		update_ncs_fqdn "1"
		
		;;

	bound|rebound|updated|informed)
		check_prefixes_changed; local prefixes_have_changed=$?;
		check_ia_b4_changed; local ia_b4_has_changed=$?;
		check_aftr_changed; local aftr_has_changed=$?;
		check_dhcp4o6_changed; local dhcp4o6_have_changed=$?;
		check_addresses_changed; local addresses_have_changed=$?;
		check_dns_changed; local dns_have_changed=$?;
		check_sntp_changed; local sntp_has_changed=$?;
		check_mcast_aftr_changed; local mcast_aftr_changed=$?;
		check_mcast_ip_changed; local mcast_ip_changed=$?;
		check_sip_domain_changed; local sip_domain_changed=$?;
		
		[ "$reason" = "rebound" ] && {	
			check_modeswitchbug_cornercase; local modeswitchbug=$?;
			
			[ $modeswitchbug -eq 1 ] && {
				clear_states
				remove_aftr "$interface"
		
				ifdown "$INTERFACE"
				sleep 5
				ifup "$INTERFACE"
				
				exit 0
			}
		}
			
		proto_init_update "$interface" 1 # lower case $interface is the ifname
		proto_set_keep 1                 # make sure pre-configured addresses / routes stay

		handle_ip6_prefixes "$PREFIXES" "$prefixes_have_changed" "$interface"

		# Set local IPv6 Address
		handle_local_addresses "$RA_ADDRESSES" "$ADDRESSES"

		# Set routes
		handle_routes "$RA_ROUTES"

		# set local IA_B4 address
		[ $ia_b4_has_changed -eq 1 ] &&  handle_ia_b4 "$OPTION_199"

		# set nameservers
		[ $dns_have_changed -eq 1 ] && handle_nameservers "$RA_DNS" "$RDNSS"

		# update NTP/SNTP servers and restart ntpd, if needed
		[ $sntp_has_changed -eq 1 ] && handle_sntpservers "$NTP_IP $NTP_FQDN $SNTP_IP"

		proto_send_update "$INTERFACE" # upper case $INTERFACE is the virtual interface

		# update AFTR related information and reset child interfaces, if needed
                [ $aftr_has_changed -eq 1 -o $ia_b4_has_changed -eq 1 -o $dhcp4o6_have_changed -eq 1 -o \
                  "(" -z "$OPTION_199" -a $addresses_have_changed -eq 1 ")" ] && {
			handle_aftr "$INTERFACE" "$AFTR" "$AFTR_IP" "$RA_ADDRESSES" "$ADDRESSES" "$DHCP4_O_DHCP6_SERVERS" "$DHCP4_O_DHCP6_MODE" "$OPTION_199"
		}

		# handle multicast AFTR settings
		[ $mcast_aftr_changed -eq 1 ] && handle_mcast_aftr "$INTERFACE" "$OPTION_124" "$RA_ADDRESSES" "$ADDRESSES" "$OPTION_199"
		[ $mcast_ip_changed -eq 1 ] && handle_mcast_ip "$INTERFACE"

		[ $mcast_aftr_changed -eq 1 -o $mcast_ip_changed -eq 1 ] && trigger_iptv_reload
		
		# handle SIP domain
		[ $sip_domain_changed -eq 1 ] && handle_sip_domain "$INTERFACE" "$SIP_DOMAIN"

		# update NCS FQDN
		update_ncs_fqdn "$addresses_have_changed"

		# reload asterisk on relevant changes
		[ $sip_domain_changed -eq 1 -o $prefixes_have_changed -eq 1 ] && /etc/init.d/asterisk-uci reload

		;;

	stopped|unbound)
		clear_states

		remove_aftr "$interface"

		proto_init_update "$interface" 0
		proto_send_update "$INTERFACE"

		;;

	*)
		log "unhandled reason $reason"

		;;

esac

exit 0
