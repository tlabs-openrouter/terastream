#!/bin/sh

# global variables:
#
#   interface   - the interface name dhclient is operating on
#   INTERFACE   - the uci config name provided to dhclient with -eINTERFACE=
#   AFTR_TUNNEL - name of the tunnel interface provided to dhclient with -eAFTR_TUNNEL=
#

. /lib/functions.sh
. /lib/netifd/netifd-proto.sh
. /lib/config/uci.sh

ip=/usr/sbin/ip

log() {
	logger -t dhclient $interface: $*
}

handle_nameservers() {
	local name_servers=$1
	for ns in $name_servers; do
		log "dns: $ns"
		proto_add_dns_server $ns
	done
}

aftr_nat() {
	local action=$1
	local tunnel_if=$2
	local ipaddr=$3
	local port_range=$4
	local to_source=$ipaddr

	[ -n "$port_range" ] && {
		to_source="${ipaddr}:${port_range}"
	}

	local old_tunnel_if="$(uci_get_state network $INTERFACE aftr_tunnel_interface)"
	local old_ipaddr="$(uci_get_state network $INTERFACE aftr_source_address)"
	local old_port_range="$(uci_get_state network $INTERFACE aftr_port_range)"
	local old_to_source="${old_ipaddr}:${old_port_range}"

	[ "${tunnel_if}${to_source}" = "${old_tunnel_if}${old_to_source}" ] && {
#		log aftr_nat DEBUG: keeping unchanged SNAT rule ${to_source}
		return 1
	}

	log aftr_nat ${action} $tunnel_if $to_source

	iptables -t nat -${action} POSTROUTING -o $tunnel_if -p tcp -j SNAT --to-source $to_source
	iptables -t nat -${action} POSTROUTING -o $tunnel_if -p udp -j SNAT --to-source $to_source
	iptables -t nat -${action} POSTROUTING -o $tunnel_if -p icmp -j SNAT --to-source $to_source
}

aftr_nat_up() {
	local tunnel_if=$1
	local ipaddr=$2
	local port_range=$3

	aftr_nat I $tunnel_if $ipaddr $port_range || return

	uci_set_state network $INTERFACE aftr_source_address $ipaddr
	uci_set_state network $INTERFACE aftr_tunnel_interface $tunnel_if
	uci_set_state network $INTERFACE aftr_port_range $port_range
}

aftr_nat_down() {
	local interface=$1
	local tunnel_if="$(uci_get_state network $interface aftr_tunnel_interface)"
	local ipaddr="$(uci_get_state network $interface aftr_source_address)"
	local port_range="$(uci_get_state network $interface aftr_port_range)"

	aftr_nat D $tunnel_if $ipaddr $port_range

	uci_revert_state network $interface aftr_tunnel_interface
	uci_revert_state network $interface aftr_source_address
	uci_revert_state network $interface aftr_port_range
}

log $reason $interface

case "$reason" in
	REBOOT|BOUND|RENEW)
		log Setting $new_ip_address/$new_subnet_mask broadcast $new_broadcast_address

		proto_init_update "$interface" 1

		proto_add_ipv4_address $new_ip_address $new_subnet_mask $new_broadcast_address
		[ ! -z "$new_dhcp_name_servers" ] && handle_nameservers $new_dhcp_name_servers

		proto_send_update "$INTERFACE"

		[ ! -z "$AFTR_TUNNEL" ] && {
			local port_range=""
			[ -n "$new_port_range_min" -a -n "$new_port_range_max" ] && port_range="$new_port_range_min-$new_port_range_max"
			
			aftr_nat_up $AFTR_TUNNEL $new_ip_address $port_range
		}

		;;
	NETIFD_DOWN)
		aftr_nat_down "$interface"
		;;
	*)
		log unhandled reason $reason
		;;
esac

exit 0
